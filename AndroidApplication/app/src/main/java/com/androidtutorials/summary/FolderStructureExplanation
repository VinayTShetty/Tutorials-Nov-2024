com.example.cleanmvvm
â”œâ”€â”€ data                          // ğŸ“¦ DATA LAYER (implements "how" data is fetched/stored)
â”‚   â”œâ”€â”€ mapper                    // ğŸ”„ MAPPERS: Convert external DTOs â†” domain models
â”‚   â”‚   â””â”€â”€ UserMappers.kt        // e.g. UserDto.toDomain() â€” keeps API schema separate from core app
â”‚   â”œâ”€â”€ remote                    // ğŸŒ REMOTE SOURCES (network/REST APIs)
â”‚   â”‚   â”œâ”€â”€ api                   // Retrofit interfaces â€” only define endpoints, no logic
â”‚   â”‚   â”‚   â””â”€â”€ UserApi.kt
â”‚   â”‚   â””â”€â”€ dto                   // Data Transfer Objects (DTOs) matching API JSON
â”‚   â”‚       â””â”€â”€ UserDto.kt
â”‚   â””â”€â”€ repository                // Repository IMPLEMENTATIONS (concrete classes)
â”‚       â””â”€â”€ UserRepositoryImpl.kt // Implements domain repository interface, uses Retrofit + Mappers
â”‚
â”œâ”€â”€ di                            // ğŸ§© DEPENDENCY INJECTION / SERVICE LOCATOR
â”‚   â””â”€â”€ ServiceLocator.kt         // Creates Retrofit, Repositories, UseCases and wires them together
â”‚
â”œâ”€â”€ domain                        // ğŸ’¡ DOMAIN LAYER (business rules, pure Kotlin)
â”‚   â”œâ”€â”€ model                     // Core entities used throughout the app
â”‚   â”‚   â””â”€â”€ User.kt
â”‚   â”œâ”€â”€ repository                // Abstract definitions (interfaces) of data operations
â”‚   â”‚   â””â”€â”€ UserRepository.kt     // e.g. fun getUsers(): List<User>
â”‚   â”œâ”€â”€ usecase                   // One class per use case (single responsibility)
â”‚   â”‚   â””â”€â”€ GetUsersUseCase.kt    // Encapsulates "Get Users" business logic
â”‚   â””â”€â”€ util                      // Shared domain utilities (e.g. Resource<T>, validation helpers)
â”‚       â””â”€â”€ Resource.kt
â”‚
â””â”€â”€ presentation                  // ğŸ¨ PRESENTATION LAYER (UI + state)
    â”œâ”€â”€ ui                        // Composables/Fragments/Activities (only show data)
    â”‚   â””â”€â”€ UsersScreen.kt
    â”œâ”€â”€ viewmodel                 // ViewModels (state holders, call UseCases)
    â”‚   â””â”€â”€ UsersViewModel.kt
    â””â”€â”€ MainActivity.kt           // Entry point Activity that sets Compose content




| Layer            | Why It Exists                                              | Why It Should Be Separate                                                                                                                            |
| ---------------- | ---------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| **data**         | Contains API calls, DB access, and mappers.                | Keeps infrastructure (Retrofit, Room) isolated, so you can switch data source (e.g. offline cache, different API) without touching business/UI code. |
| **domain**       | Core business rules (entities, use cases).                 | Independent of Android framework, Retrofit, DB, etc. This layer is 100% testable with plain JUnit.                                                   |
| **presentation** | UI & state logic (ViewModels, Compose screens, Fragments). | Keeps UI dumb â€” just observes `ViewModel` state. No network calls here.                                                                              |
| **di**           | Central place to wire dependencies.                        | Keeps construction logic out of Activities/ViewModels. If you later use Hilt/Koin, this folder becomes your `Module` definitions.                    |
